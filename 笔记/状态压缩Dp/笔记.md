# 状态压缩dp

包括**两类** ： 
1. 棋盘式（基于连通性）
2. 集合
   
##  1. 棋盘式（基于连通性）
### 1.1 P1896 [SCOI2005] 互不侵犯


#### 题目描述

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

注：数据有加强（2018/4/25）

#### 输入格式

只有一行，包含两个数N，K （ 1 <=N <=9, 0 <= K <= N \* N）

#### 输出格式

所得的方案数

#### 样例 #1

#### 样例输入 #1

```
3 2
```

#### 样例输出 #1

```
16
```

#### 闫氏Dp分析法

![](../图库/微信截图_20221102114016.png)

#### 代码

``` cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 12, M = 1 << 10, K = 110;

int n, m;
vector<int> state;
int cnt[M];
vector<int> head[M];
LL f[N][K][M];

bool check(int state)//检查state是否合法
{
    for(int i = 0; i < n; i++)
    {
        if((state >> i & 1) && (state >> i+1 & 1))//条件一 每行内部不能相邻
            return false;
    }
    return true;
}

int count(int state)//计算状态内有多少个1
{
    int res = 0;
    for(int i = 0; i < n; i++) res += state >> i & 1;
    return res;
}

int main()
{
    cin >> n >> m;
    
    for(int i = 0; i < 1 << n; i++)
    {
        if(check(i))//将合法状态记录
        {
            state.push_back(i);
            cnt[i] = count(i);
        }
    }

    for(int i = 0; i < state.size(); i++)
    {
        for(int j = 0; j < state.size(); j++)
        {
            int a = state[i], b = state[j];
            if((a & b) == 0 && check(a | b))
            {
                head[i].push_back(j);//state[i] 状态可以转移到 state[j] 状态
            }
        }
    }

    f[0][0][0] = 1;//初始状态 即正摆0行用了0个棋子状态是0的方案数为1
    for(int i = 1; i <= n + 1; i++)//多加一轮 便于输出
    {
        for(int j = 0; j <= m; j++)
        {
            for(int a = 0; a < state.size(); a++)
            {
                for(int b : head[a])
                {
                    int c = cnt[state[a]];
                    if(j >= c) f[i][j][a] += f[i-1][j-c][b];
                }
            }
        }
    }


    cout << f[n+1][m][0] << endl;

    return 0;

     
}

```



### 1.2 AcWing 327. 玉米田


#### 题目描述

农夫约翰的土地由 M×N 个小方格组成，现在他要在土地里种植玉米。

非常遗憾，部分土地是不育的，无法种植。

而且，相邻的土地不能同时种植玉米，也就是说种植玉米的所有方格之间都不会有公共边缘。

现在给定土地的大小，请你求出共有多少种种植方法。

土地上什么都不种也算一种方法。

#### 输入格式

第 1 行包含两个整数 M 和 N。

第 2..M+1 行：每行包含 N 个整数 0 或 1，用来描述整个土地的状况，1 表示该块土地肥沃，0 表示该块土地不育。


#### 输出格式

输出总种植方法对 10\^8 取模后的值。

#### 数据范围

1≤M,N≤12。

#### 样例 #1

#### 样例输入 #1

```
2 3
1 1 1
0 1 0
```

#### 样例输出 #1

```
9
```

#### 闫氏Dp分析法
![](../图库/微信截图_20221103115314.png)

#### 代码

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

const int N = 14, M = 1 << 12, mod = 1e8;

int n,m;
int g[N];//原有地图记录
vector<int> state;
vector<int> head[M];//可以从 M 状态开始转移的状态集合 
int f[N][M];

bool check(int state)
{
    for(int i = 0; i < m; i++)
    {
        if((state >> i & 1) && (state >> i+1 & 1)) return false;
    }
    return true;
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 0; j < m; j++)
        {
            int t;
            cin >> t;
            g[i] += !t << j;//原有地图记录（原有1代表能播种，需转换为0，反之亦然）
        }
    }

    for(int i = 0; i < 1 << m; i++)
    {
        if(check(i)) state.push_back(i);//所有不相邻播种状态
    }

    for(int i = 0; i < state.size(); i++)
    {
        for(int j = 0; j < state.size(); j++)
        {
            int a = state[i], b = state[j];
            if((a & b) == 0)
                head[i].push_back(j);//所有不相邻播种状态
        }
    }

    f[0][0] = 1;
    for(int i = 1; i <= n+1; i++)
    {
        for(int a = 0; a < state.size(); a++)
        {
            for(int b : head[a])
            {
                if(g[i] & state[a]) continue;//贫瘠土地
                f[i][a] = (f[i][a] + f[i-1][b]) % mod;
            }
        }
    }

    cout << f[n+1][0] << endl;//多进行一轮

    return 0;
}

```
