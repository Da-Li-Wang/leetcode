# 状态压缩dp

包括**两类** ： 
1. 棋盘式（基于连通性）
2. 集合
   
##  1. 棋盘式（基于连通性）
### 1.1 P1896 [SCOI2005] 互不侵犯


#### 题目描述

在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

注：数据有加强（2018/4/25）

#### 输入格式

只有一行，包含两个数N，K （ 1 <=N <=9, 0 <= K <= N \* N）

#### 输出格式

所得的方案数

#### 样例 #1

#### 样例输入 #1

```
3 2
```

#### 样例输出 #1

```
16
```

####闫氏Dp分析法

![](../图库/微信截图_20221102114016.png)

####代码

``` cpp
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 12, M = 1 << 10, K = 110;

int n, m;
vector<int> state;
int cnt[M];
vector<int> head[M];
LL f[N][K][M];

bool check(int state)//检查state是否合法
{
    for(int i = 0; i < n; i++)
    {
        if((state >> i & 1) && (state >> i+1 & 1))//条件一 每行内部不能相邻
            return false;
    }
    return true;
}

int count(int state)//计算状态内有多少个1
{
    int res = 0;
    for(int i = 0; i < n; i++) res += state >> i & 1;
    return res;
}

int main()
{
    cin >> n >> m;
    
    for(int i = 0; i < 1 << n; i++)
    {
        if(check(i))//将合法状态记录
        {
            state.push_back(i);
            cnt[i] = count(i);
        }
    }

    for(int i = 0; i < state.size(); i++)
    {
        for(int j = 0; j < state.size(); j++)
        {
            int a = state[i], b = state[j];
            if((a & b) == 0 && check(a | b))
            {
                head[i].push_back(j);//state[i] 状态可以转移到 state[j] 状态
            }
        }
    }

    f[0][0][0] = 1;//初始状态 即正摆0行用了0个棋子状态是0的方案数为1
    for(int i = 1; i <= n + 1; i++)//多加一轮 便于输出
    {
        for(int j = 0; j <= m; j++)
        {
            for(int a = 0; a < state.size(); a++)
            {
                for(int b : head[a])
                {
                    int c = cnt[state[a]];
                    if(j >= c) f[i][j][a] += f[i-1][j-c][b];
                }
            }
        }
    }


    cout << f[n+1][m][0] << endl;

    return 0;

     
}

```
